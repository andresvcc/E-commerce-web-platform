import { Meta, Description } from '@storybook/addon-docs'

<Meta 
  title="Mobsya/Procedures/Documentation d'un module"  
  parameters={{
    viewMode: 'docs',
    previewTabs: { 
      canvas: { hidden: true } 
     },
  }}
/>

Proc√©dure de documentation d'un module, interface, class, component
====

```Pour toute documentation, nous utilisons Storybook```

[Storybook](https://storybook.js.org) est un outil de documentation qui fournit des espaces isol√©s pour construire des interfaces utilisateur de mani√®re d√©coupl√©e. 

Ceci est utile pour d√©velopper des interfaces visuelles avec des √©tats difficiles √† atteindre et des cas limites sans avoir besoin d'ex√©cuter l'application enti√®re.

<br/><br/>

## Configuration de la documentation automatis√©e

Pour activer la documentation g√©n√©r√©e automatiquement dans les histoires, il faut ajouter la propri√©t√© de configuration tags √† l'exportation par d√©faut de l'histoire. Par exemple :

```ts
// Button.stories.ts|tsx

import type { Meta } from '@storybook/react';

import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Button',
  component: Button,
  //üëá Enables auto-generated documentation for the component story
  tags: ['autodocs'],
  argTypes: {
    backgroundColor: { control: 'color' },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    primary: true,
    label: 'Button',
  },
};

export const Secondary: Story = {
  args: {
    ...Primary.args,
    primary: false,
  },
};

```
Une fois l'histoire charg√©e, Storybook inf√®re les m√©tadonn√©es pertinentes (par exemple, args, argTypes, param√®tres) et g√©n√®re automatiquement une page de documentation avec cette information positionn√©e au niveau de la racine de l'arbre de votre composant dans la barre lat√©rale.

<br/>

## Configuration de la documentation manag√©e

La configuration g√©r√©e fait r√©f√©rence √† l'intention de ne pas utiliser le mod√®le automatique, soit parce que la documentation doit √™tre pr√©sent√©e d'une mani√®re diff√©rente, soit parce que des informations suppl√©mentaires doivent √™tre affich√©es.

Les fichier de configuration Storybook son clas√©e utilisant un des modeles suivantes

<br/>

### Dans le cas d'un composant visuel isol√©

- **Le fichier de configuration doit se trouver dans le m√™me dossier que le composant**
- **√ätre nom√©e en tenant compte du format suivant `nom du composant`.stories.tsx**

> Par exemple, un composant appel√© Button doit avoir un fichier de configuration button.stories.tsx.


##### 1. D√©finition du mod√®le (Template) utilis√© dans les histoires

Un exemples d'utilisation est pr√©sent√© ci-dessous.

```ts

// Button.stories.ts|tsx

import type { Meta } from '@storybook/react';

import { Button } from './Button';

export default {
  title: 'Button',
  component: Button,
} as ComponentMeta<typeof Button>;

const Template: ComponentStory<typeof Button> = (args) => <Button {...args} />;

```

##### 2. D√©finition des histoires

Une histoire est un cas d'utilisation, si un composant a plusieurs histoires, chaque histoire doit avoir un nom diff√©rent et une utilisation diff√©rente. 

Par exemple : Un exemples d'utilisation est pr√©sent√© ci-dessous.

```ts

// üëá history by default 
export const Default = Template.bind({});

// üëá an alternative history
export const Alternative = Template.bind({});

```

##### 3. D√©finition des paramettres (args)

L'objet args peut √™tre d√©fini au niveau de l'histoire, du composant et au niveau global. Il s'agit d'un objet JSON s√©rialisable compos√© de cl√©s de cha√Ænes de caract√®res avec des types de valeurs valides correspondants qui peuvent √™tre pass√©s dans un composant sous forme de props.

```ts

export const Default = Template.bind({});
Default.args = {
  children: 'Default Button Title',
};

```

Ces args ne s'appliqueront qu'√† l'histoire √† laquelle ils sont attach√©s, bien que vous puissiez les r√©utiliser par le biais de la r√©utilisation d'objets JavaScript.

<br/>

### Dans le cas d'une d'une classe ou d'une structure de donn√©es

- **Le fichier de configuration doit se trouver dans le m√™me dossier que la classe ou la declaration des types**
- **le fichier de configuration doit s'appeler `nom`.`type`.stories.mdx**

> Par exemple, la classe User doit √™tre nomm√©e user.class.stories.mdx

##### 1. D√©finition du mod√®le (Template) utilis√© dans les histoires

```ts

import { Meta, Story, Canvas, ArgsTable, Description } from '@storybook/addon-docs';
import { UMLWrapper, ClassStorie, StoryClass, EventStorie, CodeStorie } from 'helpers';

<Meta 
  // üëá  nom du module d√©finissant le contexte d'utilisation et nom de l'interface
  title="Modules/ThymioDiscovery/Thymio" 
/>

```

Comme l'extension du fichier est `.mdx`, l'utilisation de Markdown est support√©e. Il est donc attendu par convention de commencer par un titre qui inclut le nom de la classe ou de la structure de donn√©es. 

Par exemple : Un extrait de l'en-t√™te de la documentation de l'interface Thymio est pr√©sent√© ci-dessous.

```ts

import { Meta, Story, Canvas, ArgsTable, Description } from '@storybook/addon-docs';
import { UMLWrapper, ClassStorie, StoryClass, EventStorie, CodeStorie } from 'helpers';

<Meta 
  // üëá  nom du module d√©finissant le contexte d'utilisation et nom de l'interface
  title="Modules/ThymioDiscovery/Thymio" 
/>

[`Interface`](https://www.typescriptlang.org/docs/handbook/interfaces.html) Thymio
====

```

Dans le cas d'une interface, alors, les √©l√©ments suivants doivent √™tre inclus dans le document : 

1. Description
1. Motivation
1. Quick start
1. Exemple d'utilisation
1. Modele UML
1. Description d√©taill√©e de chaque type de donn√©es utilis√© dans l'interface, y compris ses d√©pendances

Dans le cas d'une interface qui represente le contrat d'une entit√© dont l'√©tat est partag√© avec plusieurs observateurs, les √©l√©ments √©num√©r√©s ci-dessus doivent √™tre inclus, ainsi que les √©l√©ments suivants.

1. Description des √©v√©nements et des transitions
1. Modele de la machine d'√©tat

Dans le cas d'une interface destin√©e √† √™tre utilis√©e dans le cadre d'un m√©canisme d'injection de d√©pendances, les √©l√©ments √©num√©r√©s ci-dessus doivent √™tre inclus, ainsi que les √©l√©ments suivants.

1. Description de chacune des variante
1. Liste des pr√©dicats de chaque variante

Par exemple : Un extrait de de la documentation de l'interface Thymio est pr√©sent√© ci-dessous.


```ts
import { Meta, Story, Canvas, ArgsTable, Description } from '@storybook/addon-docs';
import { UMLWrapper, ClassStorie, StoryClass, EventStorie, CodeStorie } from 'helpers';

<Meta 
  title="Domain/Thymio" 
/>

[`Interface`](https://www.typescriptlang.org/docs/handbook/interfaces.html) Thymio
====

<br /><br />

## Description
Cette interface est envisag√© pour √™tre utilis√© dans le cadre du m√©canisme d'injection de d√©pendances, elle d√©finit le contrat d'une entit√© Thymio repr√©sentant un robot et son statut de connexion au sein du module Thymio Discovery.

<br />

## Motivation
Comme pour toute interface, cela garantit que la v√©rification du type de donn√©es est coh√©rente pour toutes les impl√©mentations, c'est-√†-dire que bien que thymio 2 et thymio 3 soient deux robots compl√®tement diff√©rents avec des m√©canismes de communication diff√©rents, ils conservent le m√™me sch√©ma de conception et le m√™me mod√®le de donn√©es (coh√©rence), ce qui garantit que les deux impl√©mentations peuvent √™tre adapt√©es √† la m√™me interface de programmation.

<br /><br />

## Quick start

<CodeStorie>
{`
  @inject({ key: 'Thymio', predicate: ['thymio3'] }) thymio?: Thymio
`}
</CodeStorie>

<CodeStorie>
    {`
    @Store({ key: 'Thymio', predicate: ['thymio3'] })
    class Thymio3 implements Thymio {
      uuid: string;
      
      readonly status: Observable<ThymioStatus> = createObservable({
        key: 'Thymio Status',
        initialValue: {
          updateAt: 'new Date()',
          activity: 'initialising',
          stack: [],
        },
      });
  
      constructor(uuid: string) {
        this.uuid = uuid;
      }
  
      subscribe = (fun: (args: any) => void) => {
        const references = {
          state: this.status.state,
        };
  
        subscribe(this.status, () => fun(references));
      };
    }
    `}
</CodeStorie>

<br />

## Example of usage

<CodeStorie>
{`
@Service({ key: 'Thymio Watchman', predicate: ['offline'] })
class ThymioWatchmanOffline {
  readonly thymio: Thymio
  
  constructor(@inject({ key: 'Thymio' }) thymio?: Thymio) {
    if (!thymio) throw new Error('Session is required')
    this.thymio = thymio
  }
}
`}
</CodeStorie>

<br /><br /><br />

## Model UML

<Story 
  name="Model" 
  args={{}}>
<UMLWrapper 
  height={500}
  width={500}
  model={`
    abstract class Observable< T >{
      +key : string
      +state : T
      +set(value: T): void
    }
    enum Activity {
      executing
      updating
      receiving
      stoped
      initialising
    }
    abstract class Code {
        +value : string
    }
    class ThymioStatus {
      +updateAt : Date
      +activity : Activity
      +stack : Array<Code>
    }
    interface Thymio {
      +uuid : string
      +status : Observable<ThymioStatus>
      +subscribe()
    }
    Activity <-- ThymioStatus
    Code <-- ThymioStatus
    Observable <-- Thymio
    ThymioStatus <-- Thymio
  `}
/>
</Story>

<br /><br />

## [`Interface`](https://www.typescriptlang.org/docs/handbook/interfaces.html) Script

<Story 
  name="Thymio" 
  args={{}}>
  <ClassStorie
    type="interface"
    name="Thymio"
    uml={``}
    params={[
      {
        name: 'uuid',
        type: 'string',
        description: `Repr√©sente l'identifiant unique d√©tenu par chaque robot thymio`
      },
      {
        name: 'status',
        type: 'Observable<ThymioStatus>',
        description: `Repr√©sente l'√©tat du robot qui, dans ce cas, est contr√¥l√© par un observable.`
      }
    ]}
    methods={[
      {
        name: 'subscribe',
        description: `Comprend le m√©canisme de souscription au changement d'√©tat du robot.`,
        args: [
          {
            name: 'callback',
            type: '(args:any)=>void',
            description: ``
          }
        ]
      }
    ]}
  />
</Story>

<br /><br />

## [`Abstract Class`](https://www.typescriptlang.org/docs/handbook/2/classes.html) ThymioStatus

<Story 
  name="ThymioStatus" 
  args={{}}>
  <ClassStorie
    type="class"
    name="ThymioStatus"
    uml={`
    enum Activity {
      executing
      updating
      receiving
      stoped
      initialising
    }
    `}
    params={[
      {
        name: 'updateAt',
        type: 'Date',
        description: `Date du dernier changement de statut`
      },
      {
        name: 'activity',
        type: 'Activity',
        description: `Nom de status, d√©fini dans la liste des activit√©s`
      },
      {
        name: 'stack',
        type: 'Array<Code>',
        description: `Collection des 10 derniers √©tats`
      }
    ]}
    methods={[]}
  />
</Story>

<br />


## `Transitions and events` ([Event-driven](https://en.wikipedia.org/wiki/Event-driven_programming) )

<EventStorie
  events={[
    {
      name: `STATUS:initialising`,
      payload: `{ status: 'initialising' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat d'initialisation, ce qui signifie que le robot est encore en train d'initialiser le syst√®me et qu'il n'a pas encore commenc√© √† communiquer.`
    },
    {
      name: `STATUS:executing`,
      payload: `{ status: 'executing' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat d'ex√©cution, ce qui implique qu'il ex√©cute une instruction ou un programme.`
    },
    {
      name: `STATUS:updating`,
      payload: `{ status: 'updating' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat de rafra√Æchissement, ce qui signifie qu'il est occup√© √† rafra√Æchir une variable, un son ou un fichie.`
    },
    {
      name: `STATUS:sending`,
      payload: `{ status: 'sending' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat d'envoi, ce qui implique que le robot soit en train d'envoyer des informations par le biais d'un canal de communication.`
    },
    {
      name: `STATUS:receiving`,
      payload: `{ status: 'receiving' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat de r√©ception, ce qui implique le fait qu'il re√ßoit des informations par le biais d'un canal de communication.`
    },
    {
      name: `STATUS:stoped`,
      payload: `{ status: 'stoped' }`,
      description: `Notifie que le robot est entr√© dans l'√©tat d'arr√™t, ce qui implique que le robot n'a rien √† faire.`
    },
  ]}
/>

<br />

## Machine d'√©tat

<div>
  <iframe style={{ width: '100%', height: '70vh'}} src="https://stately.ai/viz/embed/c31bcf3c-7c9d-46ae-a201-b7deda859a4b?mode=viz&panel=code&showOriginalLink=1&readOnly=1&pan=1&zoom=1&controls=1" sandbox="allow-same-origin allow-scripts"></iframe>
</div>

```